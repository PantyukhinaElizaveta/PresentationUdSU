<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Интегральные исчисления</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/serif.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Математическая логика и теория алгоритмов
						=========================================
						Notes: Заголовок
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Меню
						----------------------
						1. Логические операции
						2. Таблица истинности
						3. Алгоритмы сортировок
						4. Сортировка массивов				
					</script>
				</section>

				
				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Определение логики высказываний 
						-------------------------------

						Раздел математической логики, изучающий логические формы сложных высказываний, 
						построенных из простых или элементарных высказываний с помощью логических операций, 
						называется **логикой высказываний**.

						Notes: — это раздел символической логики, изучающий сложные высказывания, 
						образованные из простых, и их взаимоотношения.
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						1. **Конъюнкция** (логическое умножение) 
						двух высказываний $A\text{ и }B$ — 
						это сложное логическое высказывание, 
						которое истинно только в случае истинности 
						всех составляющих высказываний, 
						в противном случае оно ложно.

						Обозначение: $A$ &$B$ или $A \wedge B$.

						Notes: Читается как A и B
						
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						2. **Дизъюнкция** (логическое сложение) 
						двух высказываний $A\text{ и }B$ — 
						это сложное логическое высказывание, 
						которое ложно только в случае ложности
						всех составляющих высказываний, 
						в противном случае оно истинно.

						Обозначение: $A \vee B$ или $A+B$.
						
						Notes: Читается как A или B
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						3. **Инверсия** (отрицание) 
						высказывания $A$ называется высказывание, 
						которое истинно, если высказывание $A$ ложно, 
						и ложно, когда $A$ истинно.

						Обозначение: $\lnot A$ или $\bar A$.
						
						Notes: логическая связка «не». Читается: «не A» («не верно, что A»). 
						Выполняется над одним аргументом.
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						4. **Импликацией** (логическим следованием) двух высказываний 
						$A\text{ и }B$ называется высказывание, которое ложно тогда и только 
						тогда, когда $A$ истинно, а $B$ ложно.

						Обозначение: $A \to B$ или $A \supset B$.
						
						Notes: Читается: «если A, то B» (« A влечет B», «из A следует B»). 
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						5. Логическая равнозначность или **эквиваленция** 
						(или эквивалентность) - это логическое выражение, 
						которое является истинным тогда, когда оба простых 
						логических выражения имеют одинаковую истинность. 

						Обозначение: $A \equiv B$ или $A \leftrightarrow B$.
						
						Notes: Читается: «A то же самое, что B» («A эквивалентно B», 
						«A тогда и только тогда, когда B»). 
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						6. **Исключающим «или»** (разделительной 
						дизъюнкцией или сложением по модулю 2) \
						двух высказываний $A\text{ и }B$ называется 
						высказывание, истинное, когда истинность значений 
						$A\text{ и }B$ не совпадает, и ложное $-$ \
						в противном случае.

						Обозначение: $A \oplus  B$.
						
						Notes: Читается: «либо A, либо B» («один или другой, но не оба вместе»). 
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						7. **Условная дизъюнкция** $-$ это тернарная 
						логическая связка для заданных операндов 
						$A, B$ и $C$. Определяется значением $A$, \
						когда $B$ истинно, и значением $C$ в противном случае.

						Обозначение:$[A, B, C]$.
						
						Notes: Читается: «если B, то A, иначе C» («A или C, в зависимости от B или не B», 
						«B подразумевает A, а не B подразумевает C»). 
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						8. **Стрелка Пирса**$-$ бинарная логическая операция. 
						Это высказывание истинно только тогда, когда ложны
						оба высказывания, входящие в это сложное высказывание.

						Обозначение: $A \downarrow B$.
						
						Notes: Читается: «ни A, ни B». 
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Логические операции в классической логике 
						-------------------------

						9. **Штрих Шеффера** — бинарная логическая операция. Высказывание 
						со штрихом Шеффера истинно тогда и только тогда, когда либо $A$ 
						ложно, либо $B$ ложно, либо $A\text{ и }B$ ложны одновременно. 
						Оно ложно и в том случае, если истинны и $A$ и $B$ одновременно.

						Обозначение: $A \mid B$.
						
						Notes: Читается: «А и В несовместны» («Неверно, что А и В»). 
					</script>
				</section>
				
				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Определение таблицы истинности 
						-------------------------

						**Таблица истинности** — это таблица, в которой отражены все значения логической 
						функции при всех возможных значениях, входящих в неё логически.
						
						Notes: Под «логической функцией» в данном случае понимается функция, 
						у которой значения переменных (параметров функции) и значение самой функции 
						выражают логическую истинность. Например, в двузначной логике они могут 
						принимать значения «истина» либо «ложь» (true либо false, 1 либо 0).
					</script>
				</section>

				<section>
					<h2>Таблицы истинности</h2>
					<select name="table" id="idTable">
						<option style="display: none;"> Выберете логическую операцию</option>
						<option value="01">Конъюнкция</option>
						<option value="02">Дизъюнкция</option>
						<!-- <option value="03">Инверсия</option> -->
						<option value="04">Импликация</option>
						<option value="05">Эквиваленция</option>
						<option value="06">Исключающее или</option>
						<!-- <option value="07">Условная дизъюнкция</option> -->
						<option value="08">Стрелка Пирса</option>
						<option value="09">Штрих Шеффера</option>
					</select>
						
					<table>
						<td>
						<table>
							<tr>
								<td>0</td>
								<td>0</td>
							</tr>
							<tr>
								<td>0</td>
								<td>1</td>
							</tr>
							<tr>
								<td>1</td>
								<td>0</td>
							</tr>
							<tr>
								<td>1</td>
								<td>1</td>
							</tr>
						</table>
						</td>	
						<td>
							<table id="tableResult"></table>
						</td>
					</table>
					<output id="outputTableResult"></output>

				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Определение алгоритма
						-----------------------
						**Алгоритм**  — конечная совокупность точно заданных правил решения некоторого класса 
						задач или набор инструкций, описывающих порядок действий исполнителя для решения 
						определённой задачи.
					
						Notes: (лат. algorithmi — от имени среднеазиатского математика Аль-Хорезми)
					</script>
				</section>


				<section data-markdown data-markdown-separator="^Notes:">
					<script type="text/template">
						Алгоритмы сортировок
						----------------------
						1. Сортировка пузырьком
						2. Сортировка перемешиванием
						3. Сортировка вставками
						4. Сортировка слиянием
						5. Сортировка выбором
						6. Пирамидальная сортировка
						7. Плавная сортировка
						8. Быстрая сортировка

						Notes: Алгоритм сортировки — это алгоритм для упорядочивания элементов в списке.
					</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Сортировка пузырьком**</h1>				
						Алгоритм состоит из повторяющихся проходов по сортируемому массиву. 
						За каждый проход элементы последовательно сравниваются и, 
						если порядок в паре неверный, выполняется обмен элементов. 
						При каждом проходе алгоритма по внутреннему циклу,
						очередной наибольший элемент массива ставится на своё место в конце 
						массива рядом с предыдущим «наибольшим элементом»,
						а наименьший элемент перемещается на одну позицию к началу массива.
						</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Сортировка перемешиванием**</h1>				
					Сортировка перемешиванием, или Шейкерная сортировка, или двунаправленная 
					(англ. Cocktail sort) — разновидность пузырьковой сортировки.
					Границы рабочей части массива (то есть части массива, где происходит движение)
					устанавливаются в месте последнего обмена на каждой итерации.
					Массив просматривается поочередно справа налево и слева направо.
						</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Сортировка вставками**</h1>				
					Сортировка вставками (англ. Insertion sort) — алгоритм сортировки,
					в котором элементы входной последовательности просматриваются по одному,
					и каждый новый поступивший элемент размещается в подходящее место
					среди ранее упорядоченных элементов
						</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Сортировка выбором**</h1>				
					Шаги алгоритма:
					------
						1. Находим номер минимального значения в текущем списке
						2. Производим обмен этого значения со значением первой
						неотсортированной позиции
						3. Теперь сортируем хвост списка, исключив из рассмотрения
						 уже отсортированные элементы
						</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Пирамидальная сортировка**</h1>				
					Сортировка пирамидой использует бинарное сортирующее дерево.
					Сортирующее дерево — это такое дерево, у которого выполнены условия:
					Каждый лист имеет глубину либо d, либо d-1, d — максимальная глубина дерева.
					Значение в любой вершине не меньше (другой вариант — не больше) значения её потомков.
						</script>
				</section>

				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Плавная сортировка**</h1>				
					Плавная сортировка (англ. Smoothsort) — алгоритм сортировки выбором,
					разновидность пирамидальной сортировки. 
					Как и пирамидальная сортировка, имеет сложность в худшем 
					случае равную O(n log n). Преимущество плавной сортировки в том,
					 что её сложность приближается к O(n), если входные данные частично 
					 отсортированы, в то время как у пирамидальной сортировки сложность
					  всегда одна, независимо от состояния входных данных.
						</script>
				</section>

				
				<section data-markdown data-markdown-separator="^Notes:">
					<h1>**Быстрая сортировка**</h1>				
					Метод основан на подходе "разделяй-и-властвуй". Общая схема такова:
					из массива выбирается некоторый опорный элемент a[i],
					запускается процедура разделения массива, которая перемещает все ключи,
					 меньшие, либо равные a[i], влево от него, а все ключи, большие, либо 
					 равные a[i] - вправо,
					теперь массив состоит из двух подмножеств, причем левое меньше, 
					либо равно правого,	для обоих подмассивов: если в подмассиве более двух элементов, 
					рекурсивно запускаем для него ту же процедуру.
						</script>
				</section>

				<section>
					<h2>Сортировка массивов</h2>
					<h3>Сортировка пузырьком</h3>
					<label for="sortInput1">Ваш массив:</label>
					<input type="text" id="sortInput1">
					<input type="button" value="Сортировать" id="_startSort1"><br/>
					<output id="sortOutput1"></output>
				</section>

				<section>
					<h2>Исходный код</h2>
					<img name = 'img' src = 'ImageBubbleSort.png' />
				</section>

				<section>
					<h2>Сортировка массивов</h2>
					<h3>Сортировка перемешиванием</h3>
					<label for="sortInput2">Ваш массив:</label>
					<input type="text" id="sortInput2">
					<input type="button" value="Сортировать" id="_startSort2"><br/>
					<output id="sortOutput2"></output>
				</section>

				<section>
					<h2>Исходный код</h2>
					<img name = 'img' src = 'ImageShackerSort.png' />
				</section>

				<section>
					<h2>Сортировка массивов</h2>
					<h3>Сортировка вставками</h3>
					<label for="sortInput3">Ваш массив:</label>
					<input type="text" id="sortInput3">
					<input type="button" value="Сортировать" id="_startSort3"><br/>
					<output id="sortOutput3"></output>
				</section>

				<section>
					<h2>Исходный код</h2>
					<img name = 'img' src = 'ImageInsertSort.png' />
				</section>

				<section>
					<h2>Сортировка массивов</h2>
					<h3>Сортировка слиянием</h3>
					<label for="sortInput4">Ваш массив:</label>
					<input type="text" id="sortInput4">
					<input type="button" value="Сортировать" id="_startSort4"><br/>
					<output id="sortOutput4"></output>
				</section>

				<section>
					<h2>Исходный код</h2>
					<img name = 'img' src = 'ImageMergeSort2.png' />
				</section>

				<section>
					<h2>Сортировка массивов</h2>
					<h3>Сортировка быстрая</h3>
					<label for="sortInput5">Ваш массив:</label>
					<input type="text" id="sortInput5">
					<input type="button" value="Сортировать" id="_startSort5"><br/>
					<output id="sortOutput5"></output>
				</section>

				<section>
					<h2>Исходный код</h2>
					<img name = 'img' src = 'ImageQuickSort.png' />
				</section>

				<section>
					<h1>Спасибо за внимание</h1>	
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>

		<script>
			window.onload = () => {
				//Таблицы
				document.querySelector('#idTable').onclick = () =>{
					let tableResult = document.querySelector('#idTable').value;
					let table = document.querySelector('#tableResult');

					switch(tableResult){
						case '01':
							table.innerHTML = "<tr><td>0</td></tr><tr><td>0</td></tr><tr><td>0</td></tr><tr><td>1</td></tr>";
							break;
						case '02':
							table.innerHTML = "<tr><td>0</td></tr><tr><td>1</td></tr><tr><td>1</td></tr><tr><td>1</td></tr>";
							break;
						case '04':
							table.innerHTML = "<tr><td>1</td></tr><tr><td>1</td></tr><tr><td>0</td></tr><tr><td>1</td></tr>";
							break;
						case '05':
							table.innerHTML = "<tr><td>1</td></tr><tr><td>0</td></tr><tr><td>0</td></tr><tr><td>1</td></tr>";
							break;
						case '06':
							table.innerHTML = "<tr><td>0</td></tr><tr><td>1</td></tr><tr><td>1</td></tr><tr><td>0</td></tr>";
							break;
						case '08':
							table.innerHTML = "<tr><td>1</td></tr><tr><td>0</td></tr><tr><td>0</td></tr><tr><td>0</td></tr>";
							break;
						case '09':
							table.innerHTML = "<tr><td>1</td></tr><tr><td>1</td></tr><tr><td>1</td></tr><tr><td>0</td></tr>";
							break;		
						default:
							table.innerHTML = "";
							break;		
						
					}
			
				};


				//СОРТИРОВКА ПУЗЫРЬКОМ
				document.querySelector('#_startSort1').onclick = () => {
					let arrayIn = document.querySelector('#sortInput1').value;
					let resultDoc = document.querySelector('#sortOutput1')
					
					function bubbleSort(arr) {
   						 for(let j=0;j<arr.length;j++) {
        					for(let i = 0; i < arr.length; i++) {
            					if(arr[i]>arr[i+1]) {
                			var temp = arr[i];
                			arr[i] = arr[i+1];
                			arr[i+1] = temp;
            			}
        			}
    			}      
    		return arr;
		}
		resultDoc.innerHTML = "["+bubbleSort(arrayIn.split(',').map(parseFloat))+"]"

    return  bubbleSort(arrayIn);
};

//СОРТИРОВКА ПЕРЕМЕШИВАНИЕМ
document.querySelector('#_startSort2').onclick = () => {
					let arrayIn = document.querySelector('#sortInput2').value;
					let resultDoc = document.querySelector('#sortOutput2')

function shakerSort(array) {
    let left = 0;
    let right = array.length - 1;
    do {
        for (let i = left; i < right; i++) {
            if (array[i] > array[i + 1]) {
                [array[i], array [i + 1]] = [array[i + 1], array [i]]
            }
        }
        right--;
        for (let i = right; left < i; i--) {
            if (array[i] < array[i - 1]) {
                [array[i], array [i - 1]] = [array[i - 1], array [i]]
            }
        }
        left++;
    } while (left < right);
return array;
}
resultDoc.innerHTML = "["+shakerSort(arrayIn.split(',').map(parseFloat))+"]"
    return shakerSort(arrayIn);

};

//СОРТИРОВКА ВСТАВКАМИ
document.querySelector('#_startSort3').onclick = () => {
					let arrayIn = document.querySelector('#sortInput3').value;
					let resultDoc = document.querySelector('#sortOutput3')

function insertSort(arr){
    for (let i = 1, l = arr.length; i < l; i++) {
        const current = arr[i];
        let j = i;
        while (j > 0 && arr[j - 1] > current) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = current;
    }
    return arr;
};
					
resultDoc.innerHTML = "["+insertSort(arrayIn.split(',').map(parseFloat))+"]"
    return insertSort(arrayIn);
};

//СОРТИРОВКА СЛИЯНИЕМ
document.querySelector('#_startSort4').onclick = () => {
					let arrayIn = document.querySelector('#sortInput4').value;
					let resultDoc = document.querySelector('#sortOutput4')

function Merge(a,low,mid,high)    //Вспомогательная функция.
{
    var b = new Array(high+1-low), h, i, j = mid+1, k, h = low, i = 0;
    while (h <= mid && j <= high )
     { if (a[h] <= a[j]){ b[ i ]=a[h]; h++; }
       else             { b[ i ]=a[j]; j++; }
       i++;
     }
    if (h > mid){ for (k = j; k <= high; k++){ b[ i ]=a[k]; i++; } }
    else        { for (k = h; k <= mid; k++){  b[ i ]=a[k]; i++; } }    
    for (k=0; k<=high-low; k++) a[k+low]=b[k];
    return a;
}

function mergeSort(A)      //Функция сортировки слиянияем.
{
    function merge_sort(a,low,high)
     { if (low < high)
        { var mid = Math.floor((low+high)/2);
          merge_sort(a, low, mid);
          merge_sort(a, mid+1, high);
          Merge(a, low, mid, high);
        }
     }
    var n = A.length;
    merge_sort(A, 0, n-1);
    return A;
}
resultDoc.innerHTML = "["+mergeSort(arrayIn.split(',').map(parseFloat))+"]"
    return mergeSort(arrayIn);
};

//СОРТИРОВКА Быстрая
document.querySelector('#_startSort5').onclick = () => {
					let arrayIn = document.querySelector('#sortInput5').value;
					let resultDoc = document.querySelector('#sortOutput5')

function quickSort(A)
{
    if (A.length == 0) return [];
    var a = [], b = [], p = A[0];
    for (var i = 1; i < A.length; i++)
     { if (A[ i ] < p) a[a.length] = A[ i ];
       else b[b.length] = A[ i ];
     }
    return quickSort(a).concat( p,quickSort(b) );
}
resultDoc.innerHTML = "["+quickSort(arrayIn.split(',').map(parseFloat))+"]"
	return quickSort(arrayIn);
};
			}
		</script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				center: false,
				slideNumber:true,
				math: {
					notificationsEnabled: true,	
				},

				dependencies: [
				{
					src: 'plugin/math-katex/math-katex.js',
					async: true,
					callback: () => {},

				}],

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
